---
title: "Combining React with D3"
date: "2016-12-14"
author:
  name: "Sam Jones"
  url: "http://twitter.com/samjonester"
---

# What Are We Building and Why?

We will be building a React component that renders a visualization using D3. I'm using a simple pie chart in this example, as the focus I'd like to take is around separating the responsibilities of our tools. This concept becomes more powerful, though, when the visualization becomes more complex.

# ADD GRAPHIC HERE!
<div id="graphic"></div>
<script src="react-d3-example.js"></script>

We will provide data to the React component, which will manage our state. The React component will render our D3 pie chart and handle component updates (i.e. state changes). We will provide a click handler to our visualization that will highlight the slice that was clicked in our pie chart.

Yes, it is definitely possible to create an SVG image with React. After all, `<svg>` is a valid tag in JSX and can simply be used within a React component's render function. However, that leads you with a lot of complicated math to perform within React. D3 has already solved this problem with handly little functions like `pie()` within their [shape](https://github.com/d3/d3-shape) library, and there are many more libraries like that available from D3. These libraries make your life easy, so instead of reinventing them, let's find a smart way to use them within React!

# Designing Our Component

Here's an example of what our new component will look like when you use it.

``` javascript
const data = [{
    name: 'Apple',
    percent: 30,
    selected: true,
    color: '#E7BD2C'
  }, {
    name: 'Cherry',
    percent: 60,
    selected: false,
    color: '#E73E2'
  }, {
    name: 'Pumpkin',
    percent: 10,
    selected: false,
    color: '#E7932C'
  }]

<Pie height={400} width={600} data={data} />
```

## What's going on here?

We've designed the interaction with our component from the outside. We can tweak it before it's built until we like the interaction. We're going to provide a height, width, and some data to our component. The data has a name for the slice in the pie chart, the percent the slice represents in the pie chart, and whether that slice is selected initially.

# Creating Our Component

Let's dive into some code! Here's the component that will accept data and produce a visualization using D3.

``` javascript
import React from 'react'
import { set } from 'lodash'

import { loadGraphic, calculateAngles } from './pie.d3'

export default class Pie extends React.Component {
  constructor(props) {
    super(props)

    this.state = {
      data: calculateAngles(this.props.data).sort(d => d.selected)
    }
  }

  selectData(indexToSelect) {
    this.setState({
      data: this.state.data
        .map((d, i) => set(d, 'selected', i === indexToSelect))
        .sort(d => d.selected)
    })
  }

  componentDidMount() {
    this.createGraphic()
  }

  componentDidUpdate() {
    this.refs.arc.innerHTML = ''
    this.createGraphic()
  }

  createGraphic() {
    loadGraphic({
      rootNode: this.refs.arc,
      data: this.state.data,
      onSliceClick: this.selectData.bind(this),
      height: this.props.height,
      width: this.props.width
    })
  }

  render() {
    return (<div ref="arc"></div>)
  }
}
```

## What's going on here?

There is a lot happening in that component. Let's dissect it to understand.

### Setting the State

``` javascript
export default class Pie extends React.Component {
  constructor(props) {
    super(props)

    this.state = {
      data: calculateAngles(this.props.data).sort(d => d.selected)
    }
  }

  // ...
}
```

First we need to instantiate a new Pie component. We want the slices to be positioned based on their incoming order, so we will calculate their angles within the pie chart before sorting. Then we will sort to will ensure that the overlapping border of the selected slice will be presented in front of the unselected slices. Then we will store prepared data as state within the component. This will allow us to recall the data later, and to provide a way to select a different slice.

### Rendering the Component

``` javascript
export default class Pie extends React.Component {
  // ...

  componentDidMount() {
    this.createGraphic()
  }

  render() {
    return (<div ref="arc"></div>)
  }

  // ...
}
```

The render function of our component will create a DOM element for D3 to attach our visualization to. We need to wait until this element is loaded into the DOM to attach the visualization. This is why we use `componentDidMount()` to attach the visualization.

### Loading the Graphic

``` javascript
export default class Pie extends React.Component {
  // ...

  createGraphic() {
    loadGraphic({
      rootNode: this.refs.arc,
      data: this.state.data,
      height: this.props.height,
      width: this.props.width,
      onSliceClick: this.selectData.bind(this)
    })
  }

  // ...
}
```

Our `createGraphic()` function will load our D3 graphic with some named values.

* `rootNode` - The DOM element to attach the visualization to.
* `data` - The prepared data with the correctly selected slice.
* `height` - The height provided to the component
* `width` - The width provided to the component
* `onSliceClick` - A function that will trigger a recalculation of the state within the component. It will be used to select the slice that was clicked.

### Updating State and Reloading

``` javascript
export default class Pie extends React.Component {
  // ...

  selectData(indexToSelect) {
    this.setState({
    data: this.state.data
      .map((d, i) => set(d, 'selected', i === indexToSelect))
      .sort(d => d.selected)
    })
  }

  // ...
}
```

This function is trigged when a slice is clicked in the graph. It will update the state within our component to update the selected slice, and sort again. Then it will trigger `componentDidUpdate` to re-render our D3 graphic.

# Rendering our Pie Graph

The first function we need to define is `calculateAngles`. This will calculate the start and end angle of each slice using the percentages. The total of all angles is `2 PI`, so we can define a function like so.

``` javascript
import merge from 'lodash/fp/merge'

export function calculateAngles(data) {
  let total = 0;
  return data.map(merge({
    startAngle: total,
    endAngle: total += Math.PI*2 * (d.percent / 100)
  }))
}
```

Now let's see what the entire D3 code looks like!

``` javascript
import { sortBy } from 'lodash'
import compose from 'lodash/fp/compose'
import { select } from 'd3-selection'
import { rgb } from 'd3-color'
import { arc as d3Arc, pie as d3Pie } from 'd3-shape'

export function loadGraphic({rootNode, data, onSliceClick, height=600, width=600}) {
  compose(
    createLegend(data, height, width),
    createChart(data, height, width, onSliceClick),
    createShadow,
    setContext(height, width)
  )(rootNode)
}

function setContext(height, width) {
  return function(rootNode) {
    return select(rootNode)
      .append('svg')
      .attr('height', `${height}px`)
      .attr('width', `${width}px`)
      .append('g')
      .attr('transform', `translate(${width/2}, ${height/2})`)
  }
}

function createShadow(rootNode) {
  const defs = rootNode.append('defs')
    // create filter with id #drop-shadow
    // height=130% so that the shadow is not clipped
    const filter = defs.append('filter')
      .attr('id', 'drop-shadow')
      .attr('height', '130%')

    // SourceAlpha refers to opacity of graphic that this filter will be applied to
    // convolve that with a Gaussian with standard deviation 3 and store result in blur
    filter.append('feGaussianBlur')
      .attr('in', 'SourceAlpha')
      .attr('stdDeviation', 2)
      .attr('result', 'blur')

    // translate output of Gaussian blur to the right and downwards with 2px
    // store result in offsetBlur
    filter.append('feOffset')
      .attr('in', 'blur')
      .attr('dx', 2)
      .attr('dy', 2)
      .attr('result', 'offsetBlur')

    // overlay original SourceGraphic over translated blurred opacity by using
    // feMerge filter. Order of specifying inputs is important!
    const feMerge = filter.append('feMerge')
    feMerge.append('feMergeNode')
      .attr('in', 'offsetBlur')
    feMerge.append('feMergeNode')
      .attr('in', 'SourceGraphic')

  return rootNode
}

function createChart(data, height, width, onSliceClick) {
  return function(rootNode) {
    const chart = rootNode.append('g')
      .selectAll('g')
      .data(pie(data), d => d.data.name)

    chart.enter().insert('path')
      .attr('d', slice(radius(height, width)))
      .on('click', (d, i) => d.data.selected || onSliceClick(i))
      .style('fill', d => d.data.selected ? 'white' : d.data.color)
      .style('stroke', d => d.data.selected ? d.data.color : 'white')
      .style('stroke-width', d => d.data.selected ? '8px' : '3px')
      .style('filter', d => d.data.selected ? 'url(#drop-shadow)' : 'none')
      .style('cursor', 'pointer')
      .on('mouseenter', function(d) {
        const prop = d.data.selected ? 'stroke' : 'fill'
        select(this).style(prop, rgb(d.data.color).brighter(1))
      })
      .on('mouseout', function(d) {
        const prop = d.data.selected ? 'stroke' : 'fill'
        select(this).style(prop, d.data.color)
      })

    chart.exit().remove()

    return rootNode
  }
}

function createLegend(data, height, width) {
  return function(rootNode) {
    const legend = rootNode.append('g')
      .selectAll('g')
      .data(sortBy(data, 'startAngle'))

    const legendItem = legend.enter().insert('g')
      .attr('transform', `translate(${-width/2 + 20}, ${-height/2 + 20})`)
    legendItem.append('rect')
      .attr('y', (d, i) => i * 20)
      .attr('width', '15')
      .attr('height', '15')
      .style('fill', d => d.color)
    legendItem.append('text')
      .attr('dy', (d, i) => i * 20 + 12)
      .attr('dx', 20)
      .attr('text-anchor', 'start')
      .style('font-size', '14px')
      .text(d => d.name)

    legend.exit().remove()

    return rootNode
  }
}

function radius(height, width) {
  return width / 2
}

function pie(data) {
  return d3Pie().value(d => d.name)(data)
}

function arc(radius) {
  return d3Arc().outerRadius(radius * 0.4).innerRadius(radius * 0.2)
}

function slice(radius) {
  return arc(radius).startAngle(d => d.data.startAngle).endAngle(d => d.data.endAngle)
}
```

## What's going on here?

### Entry Point

``` javascript
import compose from 'lodash/fp/compose'

export function loadGraphic({rootNode, data, onSliceClick, height=600, width=600}) {
  compose(
    createLegend(data, height, width),
    createChart(data, height, width, onSliceClick),
    createShadow,
    setContext(height, width)
  )(rootNode)
}
```

Our exported function will destructure our named parameters, using them to do 3 things. Each step will modify the root node using D3, which is why we are composing the actions on `rootNode`. The 3 actions being performed are:

1. Create the D3 SVG node on our root node with `setContext`.
1. Create the shadow definition used to highlight the selected item with `createShadow`.
1. Create the pie chart with `createChart`.
1. Create a legend to describe the slices.

### Create the D3 SVG Node

``` javascript
import { select } from 'd3-selection'

function setContext(height, width) {
  return function(rootNode) {
    return select(rootNode)
      .append('svg')
      .attr('height', `${height}px`)
      .attr('width', `${width}px`)
      .append('g')
      .attr('transform', `translate(${width/2}, ${height/2})`)
  }
}
```

This function will create a D3 selection from the `rootNode` and create out svg element for our chart. Then we are creating a `g` container element, centered in our svg to contain our chart. This element is returned and passed to the next function in our composition to be modified as the root node.

### Create the Shadow Definition

``` javascript
function createShadow(rootNode) {
  const defs = rootNode.append('defs')
    // create filter with id #drop-shadow
    // height=130% so that the shadow is not clipped
    const filter = defs.append('filter')
      .attr('id', 'drop-shadow')
      .attr('height', '130%')

    // SourceAlpha refers to opacity of graphic that this filter will be applied to
    // convolve that with a Gaussian with standard deviation 3 and store result in blur
    filter.append('feGaussianBlur')
      .attr('in', 'SourceAlpha')
      .attr('stdDeviation', 2)
      .attr('result', 'blur')

    // translate output of Gaussian blur to the right and downwards with 2px
    // store result in offsetBlur
    filter.append('feOffset')
      .attr('in', 'blur')
      .attr('dx', 2)
      .attr('dy', 2)
      .attr('result', 'offsetBlur')

    // overlay original SourceGraphic over translated blurred opacity by using
    // feMerge filter. Order of specifying inputs is important!
    const feMerge = filter.append('feMerge')
    feMerge.append('feMergeNode')
      .attr('in', 'offsetBlur')
    feMerge.append('feMergeNode')
      .attr('in', 'SourceGraphic')

  return rootNode
}
```

Here we are defining a filter for our drop shadow. It's being attached to our svg in a special section called `defs`. Patterns, masks, and filters are all defined here for reference by paths within an svg. Filters like this one are widely available to be added to your svg.

### Create the Pie Chart

``` javascript
import { arc as d3Arc, pie as d3Pie } from 'd3-shape'

function radius(height, width) {
  return width / 2
}

function pie(data) {
  return d3Pie().value(d => d.name)(data)
}

function arc(radius) {
  return d3Arc().outerRadius(radius * 0.4).innerRadius(radius * 0.2)
}

function slice(radius) {
  return arc(radius).startAngle(d => d.data.startAngle).endAngle(d => d.data.endAngle)
}
```

First we will define a few functions that build off D3's pie function. We'll use them when building our own Pie chart.

``` javascript
import { rgb } from 'd3-color'

function createChart(data, height, width, onSliceClick) {
  return function(rootNode) {
    const chart = rootNode.append('g')
      .selectAll('g')
      .data(pie(data), d => d.data.name)

    chart.enter().insert('path')
      .attr('d', slice(radius(height, width)))
      .on('click', (d, i) => d.data.selected || onSliceClick(i))
      .style('fill', d => d.data.selected ? 'white' : d.data.color)
      .style('stroke', d => d.data.selected ? d.data.color : 'white')
      .style('stroke-width', d => d.data.selected ? '8px' : '3px')
      .style('filter', d => d.data.selected ? 'url(#drop-shadow)' : 'none')
      .style('cursor', 'pointer')
      .on('mouseenter', function(d) {
        const prop = d.data.selected ? 'stroke' : 'fill'
        select(this).style(prop, rgb(d.data.color).brighter(1))
      })
      .on('mouseout', function(d) {
        const prop = d.data.selected ? 'stroke' : 'fill'
        select(this).style(prop, d.data.color)
      })

    chart.exit().remove()

    return rootNode
  }
}
```
Now let's actually create the chart. Using our `pie` function, we will add a new `g` group to our svg with the angles we've calculated. Next well define the custom properties for each path that represents a slice in our chart. Each attribute, or style value, can have a function that will determine the value based on the current data item.

* d - This will define the path our `path` will take using D3's pie function to calculate it's trajectory.
* onClick - We will use the click handler from our React component to select the current slice unless it's already selected.
* fill, stroke, stroke-width, filter - We want selected slices to have a white fill, bold outline, and a dropshadow, and unselected slices to have their defined color
* mouseenter, mouseout - We will highlight a slice when you mouse over it by brightening the color defined for that slice.

### Adding a Legend

``` javascript
function createLegend(data, height, width) {
  return function(rootNode) {
    const legend = rootNode.append('g')
      .selectAll('g')
      .data(sortBy(data, 'startAngle'))

    const legendItem = legend.enter().insert('g')
      .attr('transform', `translate(${-width/2 + 20}, ${-height/2 + 20})`)
    legendItem.append('rect')
      .attr('y', (d, i) => i * 20)
      .attr('width', '15')
      .attr('height', '15')
      .style('fill', d => d.color)
    legendItem.append('text')
      .attr('dy', (d, i) => i * 20 + 12)
      .attr('dx', 20)
      .attr('text-anchor', 'start')
      .style('font-size', '14px')
      .text(d => d.name)

    legend.exit().remove()

    return rootNode
  }
}
```

To finish out chart, we will add a legend describing the slices. Each slice has a color rectangle with it's name, positioned in the top left of the chart. Adding a transform to the legend anchors the container. Each legend item will get a color rectangle and a text object with padding between.

# Summary

We've separated the responsibilities of creating a Pie Chart in React by using D3. This allows React to manage state and D3 to take care of presentation. Here is a [repository](https://github.com/testdouble/react-d3-blog-example) with the working code used to generate the graphic at the top.

I haven't talked about the testing story here, but the separation above has some benefits. We can test our component as a state manager. We can use a [test double](https://github.com/testdouble/testdouble.js) to verify that state gets provided to our D3 layer properly. We can test that our data gets transformed from percentages into pie graph angles properly because that was pulled out. Unfortunately, testing breaks down in the presentation layer, since we're basically configuring a D3 pie chart. That's ok, though. It's isolated, the pie chart is verified by D3, and we can verify it with our eyes.
